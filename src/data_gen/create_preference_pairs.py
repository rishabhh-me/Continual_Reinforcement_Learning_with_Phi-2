import json
import os

PROMPT_TEMPLATE = (
    "Objective: Reach the goal.\n"
    "Rules:\n"
    "1. If you see a key and are carrying nothing, pick up the key.\n"
    "2. If you have the key and see a door, open the door.\n"
    "3. If the door is open, go to the goal.\n\n"
    "Example 1:\n"
    "Current State: You are carrying nothing. In the room, you see: yellow key, yellow door, green goal.\n"
    "Next Subgoal: Pick up the yellow key\n\n"
    "Example 2:\n"
    "Current State: You are carrying a yellow key. In the room, you see: yellow door, green goal.\n"
    "Next Subgoal: Open the yellow door\n\n"
    "Current State: {state_description}\n"
    "Next Subgoal:"
)

def process_file(input_path, output_path):
    print(f"Processing {input_path} -> {output_path}")
    if not os.path.exists(input_path):
        print(f"Skipping {input_path}, not found.")
        return

    with open(input_path, 'r') as f:
        traces = json.load(f)
    
    count = 0
    with open(output_path, 'w') as f:
        for item in traces:
            prompt = PROMPT_TEMPLATE.format(state_description=item['state_text'])
            chosen = item['canonical_subgoal']
            
            # Create a pair for each negative
            # To avoid oversampling easy states, maybe just pick 1 or 2?
            # The user instructions say: "From each expert trace create (correct, incorrect) pairs... Maintain a balanced dataset"
            # "for each correct trace include 1â€“3 plausible incorrect / partially-correct negatives."
            
            # I will include all unique negatives generated by the oracle (usually 2-3).
            
            unique_negatives = set()
            for neg_text, neg_tuple in item['negatives']:
                if neg_text == chosen: continue
                unique_negatives.add(neg_text)
            
            for neg_text in unique_negatives:
                entry = {
                    "prompt": prompt,
                    "chosen": chosen,
                    "rejected": neg_text
                }
                f.write(json.dumps(entry) + "\n")
                count += 1
    
    print(f"Wrote {count} pairs.")

if __name__ == "__main__":
    process_file("data/expert_traces_train.json", "data/dpo_train.jsonl")
    process_file("data/expert_traces_val.json", "data/dpo_val.jsonl")
    process_file("data/expert_traces_test.json", "data/dpo_test.jsonl")
